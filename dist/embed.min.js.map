{"version":3,"sources":["../src/lib/dom.js","../src/lib/embed.js","../src/lib/communication.js","../src/lib/compatibility.js","../src/lib/callback.js","../src/embed.js"],"names":["normalizeElement","element","window","jQuery","document","getElementById","HTMLElement","TypeError","nodeName","iframe","querySelector","buildIframeUrl","parameters","url","baseUrl","score","urlParameters","Object","assign","embedParams","keys","map","k","encodeURIComponent","join","createEmbedIframe","createElement","setAttribute","width","height","appendChild","postMessage","embed","method","contentWindow","Error","message","origin","parseMessage","data","JSON","parse","EmbedCallback","promises","eventCallbacks","this","name","resolve","reject","push","event","callback","length","idx","indexOf","splice","processMethodResponse","processEvent","promise","shift","error","response","forEach","call","_this","embeds","WeakMap","embedsReady","Embed","params","arguments","undefined","has","get","embedCallback","onReady","Promise","addEventListener","source","process","set","_this2","ready","then","pushCall","subscribeEvent","catch","unsubscribeEvent","revision","options","_typeof","Uint8Array","editor","active","zoom","state","position","operations","noteLocation","color","note"],"mappings":"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","file":"dist/embed.min.js.map","sourcesContent":["/**\n * Select and normalize the DOM element input\n *\n * @param {(HTMLIFrameElement|HTMLElement|string|jQuery)} element\n * @return {(HTMLIFrameElement|HTMLElement)}\n */\nexport function normalizeElement(element) {\n  if (window.jQuery && element instanceof window.jQuery) {\n    element = element[0];\n  }\n\n  // Find an element by identifier\n  if (typeof element === 'string') {\n    element = document.getElementById(element);\n  }\n\n  // Check if a DOM element\n  if (!(element instanceof window.HTMLElement)) {\n    throw new TypeError('The first parameter must be an existing DOM element or an identifier.');\n  }\n\n  // The element is not an embed iframe?\n  if (element.nodeName !== 'IFRAME') {\n    // check if already present in the element\n    const iframe = element.querySelector('iframe');\n    if (iframe) {\n      element = iframe;\n    }\n  }\n\n  return element;\n}\n","/**\n * Build url for the new iframe\n *\n * @param {object} parameters\n */\nexport function buildIframeUrl(parameters) {\n  let url = (parameters.baseUrl || 'https://flat.io/embed');\n\n  // Score id or blank embed\n  url += '/' + (parameters.score || 'blank');\n\n  // Build qs parameters\n  let urlParameters = Object.assign({\n    jsapi: true\n  }, parameters.embedParams);\n\n  let qs = Object.keys(urlParameters)\n    .map(k => `${encodeURIComponent(k)}=${encodeURIComponent(urlParameters[k])}`)\n    .join('&');\n\n  return url + '?' + qs;\n}\n\n/**\n * Create an iframe inside a specified element\n *\n * @param {HTMLElement} element\n * @param {object} parameters\n */\nexport function createEmbedIframe(element, parameters) {\n  let url = buildIframeUrl(parameters);\n\n  var iframe = document.createElement('iframe');\n  iframe.setAttribute('src', url);\n  iframe.setAttribute('width', parameters.width || '100%');\n  iframe.setAttribute('height', parameters.height || '100%');\n  iframe.setAttribute('allowfullscreen', true);\n  iframe.setAttribute('frameborder', '0');\n\n  element.appendChild(iframe);\n\n  return iframe;\n}\n","/**\n * Send a message to the embed via postMessage\n *\n * @param {Embed} embed\n * @param {string} method The name of the method to call\n * @param {string} parameters The parameters to pass to the method\n */\nexport function postMessage(embed, method, parameters) {\n  if (!embed.element.contentWindow || !embed.element.contentWindow.postMessage) {\n    throw new Error('No `contentWindow` or `contentWindow.postMessage` avaialble on the element');\n  }\n\n  let message = {\n    method,\n    parameters\n  };\n\n  embed.element.contentWindow.postMessage(message, embed.origin);\n}\n\n/**\n * Parse a message received from postMessage\n *\n * @param {string|object} data The data received from postMessage\n * @return {object}\n */\nexport function parseMessage(data) {\n  if (typeof data === 'string') {\n    data = JSON.parse(data);\n  }\n  return data;\n}\n","if (typeof window.postMessage === 'undefined') {\n  throw new Error('The Flat Embed JS API is not supported in this browser');\n}\n","\nclass EmbedCallback {\n  constructor(embed) {\n    this.embed = embed;\n    this.promises = {};\n    this.eventCallbacks = {};\n    return this;\n  }\n\n  pushCall(name, resolve, reject) {\n    this.promises[name] = this.promises[name] || [];\n    this.promises[name].push({resolve, reject});\n  }\n\n  /**\n   * Register a callback for a specified event\n   *\n   * @param {string} event The name of the event.\n   * @param {function} callback The function to call when receiving an event\n   * @return {boolen} `true` if it is the first subscriber, `false otherwise`\n   */\n  subscribeEvent(event, callback) {\n    this.eventCallbacks[event] = this.eventCallbacks[event] || [];\n    this.eventCallbacks[event].push(callback);\n    return this.eventCallbacks[event].length === 1;\n  }\n\n  /**\n   * Unregister a callback for a specified event\n   *\n   * @param {string} event The name of the event.\n   * @param {function} [callback] The function to call when receiving an event\n   * @return {boolen} `true` if it is the last subscriber, `false otherwise`\n   */\n  unsubscribeEvent(event, callback) {\n    // Was not subscribed\n    if (!this.eventCallbacks[event]) {\n      return false;\n    }\n\n    // If a callback is specified, unsub this one\n    if (callback) {\n      let idx = this.eventCallbacks[event].indexOf(callback);\n      if (idx >= 0) {\n        this.eventCallbacks[event].splice(idx, 1);\n      }\n    }\n    // Unsub all\n    else {\n      this.eventCallbacks[event] = [];\n    }\n\n    return !callback || this.eventCallbacks[event].length === 0;\n  }\n\n  /**\n   * Process a message received from postMessage\n   *\n   * @param {object} data The data received from postMessage\n   */\n  process(data) {\n    if (data.method) {\n      this.processMethodResponse(data);\n    }\n    else if (data.event) {\n      this.processEvent(data);\n    }\n  }\n\n  /**\n   * Process a method response\n   *\n   * @param {object} data The data received from postMessage\n   */\n  processMethodResponse(data) {\n    var promise = this.promises[data.method].shift();\n    if (!promise) {\n      return;\n    }\n    if (data.error) {\n      promise.reject(data.error);\n    }\n    else {\n      promise.resolve(data.response);\n    }\n  }\n\n  /**\n   * Process a receieved event\n   *\n   * @param {object} data The data received from postMessage\n   */\n  processEvent(data) {\n    if (!this.eventCallbacks[data.event] ||\n        this.eventCallbacks[data.event].length === 0) {\n      return;\n    }\n    this.eventCallbacks[data.event].forEach((callback) => {\n      callback.call(this.embed, data.parameters);\n    });\n  }\n}\n\nexport default EmbedCallback;\n","import './lib/compatibility';\n\nimport { normalizeElement } from './lib/dom';\nimport { createEmbedIframe } from './lib/embed';\nimport { postMessage, parseMessage } from './lib/communication';\nimport EmbedCallback from './lib/callback';\n\nconst embeds = new WeakMap();\nconst embedsReady = new WeakMap();\n\nclass Embed {\n  /**\n   * Create a new Flat Embed\n   *\n   * @param {(HTMLIFrameElement|HTMLElement|string|jQuery)} element A reference to a Flat Embed iframe or a container for the new iframe\n   * @param {object} [params] Parameters for the new iframe\n   * @return {Embed}\n   */\n  constructor(element, params = {}) {\n    element = normalizeElement(element);\n\n    // Keep a single object instance per iframe\n    if (embeds.has(element)) {\n      return embeds.get(element);\n    }\n\n    // Create new element iframe if needed\n    if (element.nodeName !== 'IFRAME') {\n      element = createEmbedIframe(element, params);\n    }\n\n    this.origin = '*';\n    this.element = element;\n    this.embedCallback = new EmbedCallback();\n\n    const onReady = new Promise((resolve) => {\n      // Handle incoming messages from embed\n      const onMessage = (event) => {\n        if (element.contentWindow !== event.source) {\n          return;\n        }\n\n        if (this.origin === '*') {\n          this.origin = event.origin;\n        }\n\n        // Parse inbound message\n        const data = parseMessage(event.data);\n\n        // Mark the embed as ready\n        if (data.event === 'ready' || data.method === 'ping') {\n          resolve();\n          return;\n        }\n\n        // Process regular messages from the embed\n        this.embedCallback.process(data);\n      };\n\n      window.addEventListener('message', onMessage, false);\n      postMessage(this, 'ping');\n    });\n\n    embeds.set(this.element, this);\n    embedsReady.set(this, onReady);\n\n    return this;\n  }\n\n  ready() {\n    return Promise.resolve(embedsReady.get(this));\n  }\n\n  call(method, parameters={}) {\n    return new Promise((resolve, reject) => {\n      return this.ready().then(() => {\n        this.embedCallback.pushCall(method, resolve, reject);\n        postMessage(this, method, parameters);\n      });\n    });\n  }\n\n  /**\n   * Subscribe to a specific event\n   *\n   * @param {string} event The name of the event.\n   * @param {function} callback The function to call when receiving an event\n   */\n  on(event, callback) {\n    if (typeof event !== 'string') {\n      throw new TypeError('An event name (string) is required');\n    }\n    if (typeof callback !== 'function') {\n      throw new TypeError('An callback (function) is required');\n    }\n    if (this.embedCallback.subscribeEvent(event, callback)) {\n      this.call('addEventListener', event).catch(() => {});\n    }\n  }\n\n  /**\n   * Unsubscribe to a specific event\n   *\n   * @param {string} event The name of the event.\n   * @param {function} [callback] The function to unsubscribe\n   */\n  off(event, callback) {\n    if (typeof event !== 'string') {\n      throw new TypeError('An event name (string) is required');\n    }\n    if (this.embedCallback.unsubscribeEvent(event, callback)) {\n      this.call('removeEventListener', event).catch(() => {});\n    }\n  }\n\n  /**\n   * Load a score hosted on Flat\n   *\n   * @param {string} score The unique identifier of the score\n   * @param {string} [revision] The unique identifier of the revision\n   * @return {Promise}\n   * @reject {ApiError} Unable to load the score\n   */\n  loadFlatScore(score, revision) {\n    return this.call('loadFlatScore', {score, revision});\n  }\n\n  /**\n   * Load a MusicXML score\n   *\n   * @param {string} score The MusicXML file\n   * @return {Promise}\n   * @reject {Error} Unable to load the score\n   */\n  loadMusicXML(score) {\n    return this.call('loadMusicXML', score);\n  }\n\n  /**\n   * Load a Flat JSON score\n   *\n   * @param {object|string} score The JSON of the score\n   * @return {Promise}\n   * @reject {Error} Unable to load the score\n   */\n  loadJSON(score) {\n    return this.call('loadJSON', score);\n  }\n\n  /**\n   * Get the score in Flat JSON format\n   *\n   * @return {Promise}\n   * @fulfill {object} The Flat data format\n   */\n  getJSON() {\n    return this.call('getJSON');\n  }\n\n  /**\n   * Convert the displayed score in MusicXML\n   *\n   * @param {object} options Conversion options (`compressed`)\n   * @return {Promise}\n   * @fullfill {string|Uint8Array} MusicXML File\n   * @reject {Error} Conversion error\n   */\n  getMusicXML(options) {\n    return new Promise((resolve, reject) => {\n      options = options || {};\n      if (typeof options !== 'object') {\n        return reject(new TypeError('Options must be an object'));\n      }\n      this.call('getMusicXML', options).then((data) => {\n        // Plain XML\n        if (typeof data === 'string') {\n          return resolve(data);\n        }\n        // Compressed, re-create Uint8Array\n        return resolve(new Uint8Array(data.data));\n      }).catch(reject);\n    });\n  }\n\n  /**\n   * Convert the displayed score in PNG\n   *\n   * @return {Promise}\n   * @fullfill {Uint8Array} PNG File\n   * @reject {Error} Conversion error\n   */\n   getPNG(options) {\n     return new Promise((resolve, reject) => {\n       options = options || {};\n       if (typeof options !== 'object') {\n         return reject(new TypeError('Options must be an object'));\n       }\n       this.call('getPNG', options).then((data) => {\n         if (typeof data === 'string') {\n           return resolve(data);\n         }\n         return resolve(new Uint8Array(data));\n       }).catch(reject);\n     });\n   }\n\n  /**\n   * Get the metadata of the score (for scores hosted on Flat)\n   *\n   * @return {Promise}\n   * @fulfill {object} The Flat data format (result from https://flat.io/developers/api/reference/#operation/getScore)\n   */\n  getFlatScoreMetadata() {\n    return this.call('getFlatScoreMetadata');\n  }\n\n  /**\n   * Get the whole embed config\n   *\n   * @return {Promise}\n   * @fullfill {object} An object containing the config of the embed\n   */\n   getEmbedConfig() {\n     return this.call('getEmbedConfig');\n   }\n\n  /**\n   * Set a config for the embed mode\n   * This config can be fetched with `getEmbed()` (as `editor` value)\n   * This config will be applied at the next score loading\n   *\n   * @param {object} editor The editor config\n   * @return {Promise}\n   * @fullfill {object} An object containing the config of the editor\n   */\n   setEditorConfig(editor) {\n     return this.call('setEditorConfig', editor);\n   }\n\n  /**\n   * Toggle fullscreen state\n   *\n   * @param {boolean} active `true` to switch on fullscreen, `false` to switch off\n   * @return {Promise} Once the state changed\n   */\n  fullscreen(active) {\n    return this.call('fullscreen', active);\n  }\n\n  /**\n   * Start the playback\n   *\n   * @return {Promise}\n   */\n  play() {\n    return this.call('play');\n  }\n\n  /**\n   * Pause the playback\n   *\n   * @return {Promise}\n   */\n  pause() {\n    return this.call('pause');\n  }\n\n  /**\n   * Stop the playback\n   *\n   * @return {Promise}\n   */\n  stop() {\n    return this.call('stop');\n  }\n\n  /**\n   * Mute playback\n   *\n   * @return {Promise}\n   */\n  mute() {\n    return this.call('mute');\n  }\n\n  /**\n   * Print the score\n   *\n   * @return {Promise}\n   */\n  print() {\n    return this.call('print');\n  }\n\n  /**\n   * Get the current zoom ratio\n   *\n   * @return {Promise}\n   * @fullfill {number} The current scale ratio (0.5 to 3)\n   */\n  getZoom() {\n    return this.call('getZoom');\n  }\n\n  /**\n   * Set a new zoom ratio (this will disable the zoom auto if set)\n   *\n   * @param {number} zoom The scale ratio (0.5 to 3)\n   * @return {Promise}\n   * @fullfill {number} The scale ratio applied\n   */\n  setZoom(zoom) {\n    return this.call('setZoom', zoom);\n  }\n\n  /**\n   * Get the auto-zoom\n   *\n   * @return {Promise}\n   * @fullfill {boolean} `true` if enabled, `false` if disabled\n   */\n  getAutoZoom() {\n    return this.call('getAutoZoom');\n  }\n\n  /**\n   * Enable or disable the auto-zoom\n   *\n   * @param {boolean} state `true` if enabled, `false` if disabled\n   * @return {Promise}\n   * @fullfill {boolean} The auto-zoom mode\n   */\n  setAutoZoom(state) {\n    return this.call('setAutoZoom', state);\n  }\n\n  /**\n   * Set the focus to the score\n   *\n   * @return {Promise}\n   */\n  focusScore() {\n    return this.call('focusScore');\n  }\n\n  /**\n   * Get cursor position\n   *\n   * @return {Promise}\n   * @fullfill {boolean} Current cursor position\n   */\n  getCursorPosition() {\n    return this.call('getCursorPosition');\n  }\n\n  /**\n   * Set cursor position\n   *\n   * @param {object} position New cursor position\n   * @return {Promise}\n   * @fullfill {boolean} Current cursor position\n   */\n  setCursorPosition(position) {\n    return this.call('setCursorPosition', position);\n  }\n\n  /**\n   * Call Flat's internal edit methods\n   *\n   * @param {operations} The operations to process\n   */\n  edit(operations) {\n    return this.call('edit', operations);\n  }\n\n  /**\n   * Set note color\n   *\n   * @param {noteLocation} position of the note to change\n   * @param {color} The color to apply\n   */\n  setNoteColor(noteLocation, color) {\n    return this.call('setNoteColor', { note: noteLocation, color: color });\n  }\n}\n\nexport default Embed;\n"]}